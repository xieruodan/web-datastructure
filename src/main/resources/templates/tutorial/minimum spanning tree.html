<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <title>TUTORIAL-MINIMUM SPANNING TREE</title>

    <link rel="stylesheet" href="css/main.css" />

    <div th:replace="common :: homeCommonStyle"></div>
</head>
<body class="is-preload"  style="background-color:#F4F4F4;">
<!-- Header -->
<header id="header">
    <div th:replace="common :: homeCommonHeader4"></div>
    <div th:replace="common :: homeCommonHeader5"></div>
    <nav style="float:right;margin:0 auto;margin-right:-20px;">
        <a th:href="@{/animation/sorting}">Animation</a>
    </nav>
    <div th:replace="common :: homeCommonHeader1"></div>
    <div th:replace="common :: homeCommonHeader6"></div>
    <div th:replace="common :: homeCommonHeader2"></div>
    <div th:replace="common :: homeCommonHeader3"></div>
</header>


<!-- Heading -->
<div id="heading" >
    <h1>最小生成树</h1>
</div>

<!-- Main -->
<section id="main" class="wrapper">
    <div class="inner">
        <div class="content">


            <header>
                <h2>Prim算法</h2>
            </header>
            <h3>算法简介：</h3>
            <img src="images/m9.png" alt="m9" width="618" height="518">
            <p>普里姆算法（Prim算法），图论中的一种算法，可在加权连通图里搜索最小生成树。意即由此算法搜索到的边子集所构成的树中，不但包括了连通图里的所有顶点（英语：Vertex (graph theory)），且其所有边的权值之和亦为最小。该算法于1930年由捷克数学家沃伊捷赫·亚尔尼克（英语：Vojtěch Jarník）发现；并在1957年由美国计算机科学家罗伯特·普里姆（英语：Robert C. Prim）独立发现；1959年，艾兹格·迪科斯彻再次发现了该算法。因此，在某些场合，普里姆算法又被称为DJP算法、亚尔尼克算法或普里姆－亚尔尼克算法。</p>
            <p>Prim算法从任意一个顶点开始，每次选择一个与当前顶点集最近的一个顶点，并将两顶点之间的边加入到树中。Prim算法在找当前最近顶点时使用到了贪婪算法。</p>
            <p>算法描述：</p>
            <p>1.在一个加权连通图中，顶点集合V，边集合为E。 </p>
            <p>2.任意选出一个点作为初始顶点,标记为visit,计算所有与之相连接的点的距离，选择距离最短的，标记visit。</p>
            <p>重复以下操作，直到所有点都被标记为visit：在剩下的点中，计算与已标记visit点距离最小的点，标记visit,证明加入了最小生成树。</p>
            <h3>实例展示：</h3>
            <p>如下图所示，图a是一个连通图（右图是图a对应的邻接矩阵，假设图中的边的权值大于0），我们现在基于该图来演示Prim算法的过程。</p>
            <img src="images/m1.png" alt="m1" width="242" height="256">
            <img src="images/m2.png" alt="m2" width="336" height="314">
            <p>我们选择一个起点，然后在与起点相连且未被选的节点中选择一个权值最小的节点，将该节点与其相连边添加入生成树。假设起点是0节点，与0节点相连且未被选的节点是{1,2,3}，分别对应的权值是{6,1,5}，可见当前最小的权值1，权值最小的节点就是2节点，所以将2节点和0-2的边添加入生成树，如图b所示。</p>
            <img src="images/m3.png" alt="m3" width="242" height="256">
            <p>接着我们在与已选节点相连且未被选的节点中选择一个权值最小的节点，将该节点与其相连边添加入生成树。当前已选节点是0,2节点，与已选节点相连且未被选的节点有{1,3,4,5}，分别对应的权值是{（6,5），（5,5），6,4,}，可见当前最小的权值4，权值最小的节点就是5节点，所以将5节点和2-5的边添加入生成树，如图c所示。（其实在编程时，我们只需记录与更新当前较小的那个权值，如与{1,3,4,5}对应的权值我们只需记录{5,5,6,4}，当然我们也需利用了另一个数组来加以区别当前权值对应的连接点，如当前权值{5,5,6,4}所对应的连接点就是{2,0,2,2}）</p>
            <img src="images/m4.png" alt="m4" width="242" height="256">
            <p>接着我们继续在与已选节点相连且未被选的节点中选择一个权值最小的节点，将该节点与其相连边添加入生成树。当前已选节点是0,2,5节点，与已选节点相连且未被选的节点有{1,3,4}，分别对应的权值是{（6,5），（2,5,5），（6,6）,}（其实当前我们可只记录{5,2,6}，同时记录其对应的连接点分别是{2,5,2}），可见当前最小的权值2，权值最小的节点就是3节点，所以将3节点和5-3的边添加入生成树，如图d所示。</p>
            <img src="images/m5.png" alt="m5" width="242" height="256">
            <p>接着我们依照上一次的步骤继续在与已选节点相连且未被选的节点中选择一个权值最小的节点，将该节点与其相连边添加入生成树。如图e，f所示。最终图f就是我们通过Prim算法得到的最小生成树了。</p>
            <img src="images/m6.png" alt="m6" width="242" height="256">
            <img src="images/m7.png" alt="m7" width="242" height="256">
            <h3>编程实现：</h3>
            <img src="images/m8.png" alt="m8" width="800" height="380">
            <h3>时间复杂度：</h3>
            <p>Prim算法中有两重for循环，所以时间复杂度为O(n^2)，其中n为图的顶点个数。</p>
            <hr />
            <h2>Kruskal算法</h2>
            <h3>算法简介：</h3>
            <p>克鲁斯卡尔算法是一种用来寻找最小生成树的算法。在剩下的所有未选取的边中，找最小边，如果和已选取的边构成回路，则放弃，选取次小边。</p>
            <p>克鲁斯卡尔(Kruskal)算法是实现图的最小生成树最常用的算法。</p>
            <h3>基本思想：</h3>
            <p>克鲁斯卡尔算法的基本思想是以边为主导地位，始终选择当前可用（所选的边不能构成回路）的最小权植边。所以Kruskal算法的第一步是给所有的边按照从小到大的顺序排序。这一步可以直接使用库函数qsort或者sort。接下来从小到大依次考察每一条边（u，v）。</p>
            <p>先构造一个只含 n 个顶点、而边集为空的子图，把子图中各个顶点看成各棵树上的根结点，之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，即把两棵树合成一棵树，反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直到森林中只有一棵树，也即子图中含有 n-1 条边为止。</p>
            <p>时间复杂度为为O(e^2), 使用并查集优化后复杂度为 O（eloge），与网中的边数有关，适用于求边稀疏的网的最小生成树。</p>
            <p>具体实现过程如下：</p>
            <p>1.设一个有n个顶点的连通网络为G（V,E），最初先构造一个只有n个顶点，没有边的非连通图T={V,空}，图中每个顶点自成一格连通分量。</p>
            <p>2.在Ｅ中选择一条具有最小权植的边时，若该边的两个顶点落在不同的连通分量上，则将此边加入到Ｔ中；否则，即这条边的两个顶点落到同一连通分量      上，则将此边舍去（此后永不选用这条边），重新选择一条权植最小的边。</p>
            <p>3.如此重复下去，直到所有顶点在同一连通分量上为止。</p>
            <h3>实例展示：</h3>
            <p>对如下图所示使用Kruskal算法：</p>
            <img src="images/m10.png" alt="m10" width="600" height="320">
            <p>算法处理过程如下：</p>
            <img src="images/m11.png" alt="m11" width="600" height="320">
            <p>处理边AF，点A与点F不在同一个集合里，选中AF。</p>
            <img src="images/m12.png" alt="m12" width="600" height="320">
            <p>处理边DE，点D与点E不在同一个集合里，选中DE。</p>
            <img src="images/m13.png" alt="m13" width="600" height="320">
            <p>处理边BD，点B与点D不在同一个集合里，选中BD。</p>
            <img src="images/m14.png" alt="m14" width="600" height="320">
            <p>处理边BC，点B与点C不在同一个集合里，选中BC。</p>
            <img src="images/m15.png" alt="m15" width="600" height="320">
            <p>处理边CD，点C与点D在同一个集合里，放弃CD。</p>
            <p>处理边BF，点B与点F不在同一个集合里，选中BF。</p>
            <p>至此，所有的点都连在了一起，剩下的边DF，AE，AB，EF不用继续处理了，算法执行结束。</p>





        </div>
    </div>
</section>

<!--home common footer-->
<div th:replace="common :: homeCommonFooter"></div>

<!--home common script-->
<div th:replace="common :: #homeCommonScript"></div>

</body>
</html>