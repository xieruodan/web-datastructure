<!DOCTYPE html>
<html lang="en" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="description" content="" />
    <meta name="keywords" content="" />

    <title>TUTORIAL-SORTING</title>

    <link rel="stylesheet" href="css/main.css" />

    <div th:replace="common :: homeCommonStyle"></div>
</head>
<body class="is-preload"  style="background-color:#F4F4F4;">
<!-- Header -->
<header id="header">
    <div th:replace="common :: homeCommonHeader4"></div>
    <div th:replace="common :: homeCommonHeader5"></div>
    <nav style="float:right;margin:0 auto;margin-right:-20px;">
        <a th:href="@{/animation/sorting}">Animation</a>
    </nav>
    <div th:replace="common :: homeCommonHeader1"></div>
    <div th:replace="common :: homeCommonHeader6"></div>
    <div th:replace="common :: homeCommonHeader2"></div>
    <div th:replace="common :: homeCommonHeader3"></div>
</header>


<!-- Heading -->
<div id="heading" >
    <h1>排序算法</h1>
</div>

<!-- Main -->
<section id="main" class="wrapper">
    <div class="inner">
        <div class="content">
            <header>
                <h2>插入排序</h2>
            </header>
            <h3>算法简介：</h3>
            <p>有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法,插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
            <p>插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p>
            <p>插入排序对于少量元素的排序是一个有效的算法。插入排序的工作方式像许多人排序一手扑克牌。开始时，我们的左手为空并且桌子上的牌面向下。然后，我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从左到右将它与已在手中的每张牌进行比较。拿在左手上的牌总是排序好的，原来这些牌是桌子上牌堆中顶部的牌。</p>
            <p>对于插入排序，我们将其伪代码过程命名为INSERTION-SORT，其中的参数是一个数组A[1..n]，包含长度为n的要排序的一个序列（在代码中，A中元素的数目n用A.length来表示。）该算法原址排序输入的数：算法在数组A中重排这些数，在任何时候，最多只有其中的常数个数字存储在数组外面。在过程INSERTION-SORT结束时，输入数组A包含排序号的输出序列。</p>
            <h3>相关术语：</h3>
            <p>关键码：</p>
            <p>关键码是数据元素中某个数据项的值，用它可以标示一个数据元素。通常会用记录来标示数据元素，一个记录可以有若干数据项组成。例如，一个学生的信息就是一条记录，它包括学号，姓名，性别等若干数据项。主关键码可以唯一的标示一个记录的关键码，如学号。次关键码是可以标示若干记录的关键字，如性别、姓名。</p>
            <p>假设一个文件有n条记录{}，对应的关键码是{}，排序家就是将此n个记录按照关键码的大小递增（或递减）的次序排列起来，使这些记录由无序变为有序的一种操作。排序后的序列若为{}时，其对应的关键码值满足{}或{}。</p>
            <p>若在待排序的记录中，存在两个或两个以上的关键码值相等的记录，经排序后这些记录的相对次序仍然保持不变，则称相应的排序方法是稳定的方法，否则是不稳定的方法。</p>
            <p>内部排序和外部排序：</p>
            <p>根据排序过程中涉及的存储器不同，可以将排序方法分为两大类：一类是内部排序，指的是待排序的几率存放在计算机随机存储器中进行的排序过程；另一类的外部排序，指的是排序中要对外存储器进行访问的排序过程。</p>
            <p>内部排序是排序的基础，在内部排序中，根据排序过程中所依据的原则可以将它们分为5类：插入排序、交换排序、选择排序、归并排序和基数排序；根据排序过程的时间复杂度来分，可以分为三类：简单排序、先进排序、基数排序。</p>
            <p>评价排序算法优劣的标准主要是两条：一是算法的运算量，这主要是通过记录的比较次数和移动次数来反应；另一个是执行算法所需要的附加存储单元的的多少。</p>
            <h3>算法代码：</h3>
            <img src="images/sorting1.png" alt="sort1" width="800" height="700">
            <h3>复杂度分析：</h3>
            <p>插入排序的时间复杂度 就是判断比较次数有多少，而比较次数与 待排数组的初始顺序有关，当待排数组有序时，没有移动操作（第8行for不成立），此时复杂度为O(N)，当待排数组是逆序时，比较次数达到最大--对于下标 i 处的元素，需要比较 i-1 次。总的比较次数：1+2+...+N-1 ，故时间复杂度为O(N^2)</p>
            <p>可以看出，算法中只用到了一个临时变量（第6行），故空间复杂度为O(1)</p>
            <h3>补充说明：</h3>
            <p>其实，插入排序的比较次数与数组的逆序数相关，因为插入排序在将某个元素插入到合适位置时（代码第12行），其实就是消除这个元素的逆序数。由定理：N个互异数的数组的平均逆序数是 N(N-1)/4，可知：基于相邻元素之间的比较和交换的算法的时间复杂度的一个下界为O(N^2)比较冒泡排序啊。。。。它采用的思路是：相邻两个元素比较，将小的放在前头。故冒泡排序的时间复杂度为O(N^2)。。。基于上面这个定理，另外一个排序算法：希尔排序，采用了增量序列。因此，它可能获得一个更好的时间复杂度。比如，当希尔排序使用Hibbard增量序列时，它的最坏运行时间为O(N3/2)</p>
            <hr />
            <h2>冒泡排序</h2>
            <h3>算法简介：</h3>
            <p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
            <p>冒泡排序是一种极其简单的排序算法，它重复地走访过要排序的元素，依次比较相邻两个元素，如果他们的顺序错误就把他们调换过来，直到没有元素再需要交换，排序完成。这个算法的名字由来是因为越小(或越大)的元素会经由交换慢慢“浮”到数列的顶端。</p>
            <p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
            <h3>算法原理：</h3>
            <p>1.比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。</p>
            <p>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
            <p>3.针对所有的元素重复以上的步骤，除了最后一个。</p>
            <p>4.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</p>
            <h3>算法稳定性：</h3>
            <p>冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。</p>
            <h3>时间复杂度：</h3>
            <p>1.如果我们的数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。</p>
            <p>2.如果很不幸我们的数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：</p>
            <img src="images/sorting2.jpg" alt="sort2" width="322" height="116">
            <p>冒泡排序的最坏时间复杂度为：O(n2) 。</p>
            <p>综上所述：冒泡排序总的平均时间复杂度为：O(n2) 。</p>
            <h3>算法代码：</h3>
            <img src="images/sorting3.png" alt="sort3" width="800" height="700">

        </div>
    </div>
</section>

<!--home common footer-->
<div th:replace="common :: homeCommonFooter"></div>

<!--home common script-->
<div th:replace="common :: #homeCommonScript"></div>

</body>
</html>